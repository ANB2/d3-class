%meta{encoding: "utf-8"}
%title Visualising Data Using Javascript
%link{href:"css/screen.css",rel:"stylesheet"}
%script{src:"underscore.js"}
%script{src:"d3.js"}
%script{src:"treemap.js"}

:javascript


%section
  %h1 Visualising Data Using Javascript
  %h2
    Tim Ruffles - 
    %a{href:"https://www.sidekickjs.com"} SidekickJS
  %h3{class:"twitter"}
    %a{href:"https://twitter.com/timruffles"} @timruffles


%section#intro-venn





%section.subtitle
  %h2 d3: what &amp; why of d3

%section



  :javascript
   
  %style
    :sass
%section
  %h2 Philosophy

  %p Don't invent a propritatory API - use SVG, HTML. You'll see 'g' elements just like in SVG, not new names for old things (eg jQuery - `dataType` not `responseType`).

  %p Toolkit for visualisations, not lots of prebaked ones.

  %p Definitely not a charting library.

%section
  %h2 Why

  %p Not propriatory - you can use what you learn about SVG, HTML and CSS everywhere.

  %p Mobile friendly (HTML everywhere, SVG iOS, Android Browser 3.0+).

  %p Less to learn - not a big scary black box.

%section.subtitle
  %h2 Selecting elements

%section
  %h2 API

  %pre
    :preserve
      d3.select("body")
        .append("h2")
        .text("foo")
        .transition()
          .style("color","red");

      d3.select("p")
        .style("font-size","2em")
        .append("span")
          .text("I'm a span in a paragraph");

%section
  %h2 Chaining

  %p Just like jQuery, we can keep calling methods on the same elements.

  %p If we create new elements via append, the context of our chain becomes the new elements.

  %p Use `transition` to apply changes over time.

%section
  %h2 Context

  %p We need to be aware of which elements we're talking about

  %pre
    :preserve
      // results in &lt;h2&gt;&lt;a&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/h2&gt;
      d3.select("body")
        .append("h2") // now we're in context of h2
        .append("a") // so a ends up inside h2
        .append("span"); // and span inside a

      // results in &lt;h2&gt;&lt;a&gt;&lt;/a&gt;&lt;span&gt;&lt;/span&gt;&lt;/h2&gt;
      var h2 = d3.select("body")
        .append("h2");
      h2.append("a");
      h2.append("span");



%section
  %h2 Events

  %pre
    :preserve
      d3.selectAll("input")
        .on("change",function(data,index) {
          // event handler
        });

  %p Again, very similar to jQuery, `this` being DOM element.
  %p `d3.event` holds current event
  %p `this` for target DOM node

%section.subtitle

  %h2 What are `data` and `index` doing where `event` is normally...?

%section.subtitle
  %h2 We need to talk about data

%section#data-demo
  %h2 Data

  %ul

  :javascript
    onPage("data-demo",function() {
      var sections = d3.select("#data-demo ul")
        .selectAll("li")
        .data([
          "d3 gets data in front of users by binding it to elements.",
          "You can then use it to dynamically setup attributes *",
          "It'll be passed to your event handers"
        ])
        .enter()
          .append("li")
          .style("opacity",0)
          .text(function(d) { return d }) // * dynamic
          .transition()
          .delay(function(d,i) { return i * 1000 })
          .style("opacity",1)
    });

  :javascript
    onPage("data-demo",function() {
      setTimeout(function() {
        revealCode("data-demo") 
      },3500);
    });

%section
  %h2 Joins

  %p In the code for the comparison, before we have any data we select all divs.

  %p Why are we binding to elements that don't exist?

  %pre
    :preserve
      var sections = d3.select("#demo1")
        .append("div")
        .classed("graphs",true)
        .selectAll("div")

  %p Why isn't this a waste of time?


%section#change
  %h2 Reflecting change

  %p Three types - new data, change in values, data leaving

  #change-demo

  %button#change-btn
    Change

  :javascript
    onPage("change",function() {
    var draw = function() {
      var root = d3.select("#change-demo")

      var colors = d3.scale.linear().domain([-2,2]).range(["#FF0000","#0000FF"]);

      var s = root.selectAll("div").data(d3.range(Math.round(Math.random()  * 10)).map(d3.random.normal()));

      // update method
      s.transition()
        .style("color",function(d)  { return colors(d) })
        .text(I);

      // data without elements
      s.enter()
          .append("div")
          .style({opacity: 0})
          .text(I)
          .transition()
            .delay(function(d,i) { return i * 250 })
            .style("color",function(d)  { return colors(d) })
            .style({opacity: 1})

      // elements without data
      s.exit()
          .transition()
          .delay(function(d,i) { return i * 250 })
          .style({opacity: 0})
          .remove();
    }
    d3.select("#change-btn").on("click",draw);
      draw();
    });

  :javascript
    onPage("change",function() {
      setTimeout(function() {
        revealCode("change") 
      },2500);
    });

%section
  %h2 Update

  %p You're setting rules for updates as soon as you bind data

  %p Updates apply when you have both an element and a datum

  %p Rerun the selection when adding data, attributes will be updated

  %p Use transitions to move smoothly to the new values

  %pre
    :preserve
      d3.selectAll("div") // 1 div
        .data([1,2,3,4])
        // will act on the first div, passing 1
        .text(function(d) { 
          return "I'm updating " + 1 // I'm updating 1
         }) 

%section
  %h2 Enter

  %p New data that doesn't fit into the current selection goes into enter

  %p eg:

  %pre
    :preserve
      d3.selectAll("div") // 1 div
        .data([1,2,3,4])

      d3.enter() // will act on [2,3,4], appending 3 divs
        .append("div") 

%section
  %h2 Exit

  %p Elements that no longer have a datum will go into exit

  %p eg:

  %pre
    :preserve
      d3.selectAll("div") // 5 divs
        .data([1])

      d3.exit() // will affect the other 4 divs, removing them
        .remove()


%section
  %h2 Key functions

  %p If we change data, we need a way for d3 (and us) to know it's actually referring to the same thing.

  %p Initially datums are identified by position in array - if we change order this breaks.

  %p Key fn tells d3 which of the values is a unique key.

  %pre
    :preserve
      var data = [
        {"name":"jquery", data: [["dom",1], ["svg",0], ["data",0], ["open",0.7 ]]},
        {"name":"d3", data: [ ["dom",0.8], ["svg",1], ["data",1], ["open",1 ]]},
        {"name":"highcharts", data:[ ["dom",0], ["svg",1], ["data",1], ["open",0 ]]},
        {"name":"raphael", data: [["dom",0], ["svg",1], ["data",0], ["open",0.5 ]]},
        {"name":"processing", data:[ ["dom",0], ["svg",0], ["data",0.5], ["open",0.2 ]]}
      ];

      var sections = d3.select("#demo1")
        .append("div")
        .classed("graphs",true)
        .selectAll("div").data(data,pluck("name"))

%section
  %h2 Hierarchy

  %p We can reflect a hierarchical set of data in elements

  %pre
    :preserve
      var sections = d3.select("#demo1")
        .append("div")
        .classed("graphs",true)
        .selectAll("div").data(data,pluck("name"))

      sections.enter()
          .append("div")
          .classed("data-framework",true)
          .append("h2")
          .text(pluck("name"))
          ;

  %p In our framework comparison we had a set of frameworks each with 4 attributes.

  %p So we need a set of 5 elements each containing 4 elements.

%section
  %h2 Loading data

  %p Don't need to include jQuery - has facilities to load CSV, JSON etc

  %pre
    :preserve
      d3.csv(url,function(csv) {
        // remember to parse your data - csv is stringly typed
      });

      d3.json(url,function(tastyData) {

      });

%section
  %h2 Munging data

  %p d3 includes the JS 1.6 array methods - `filter`, `map`, `reduce` etc

  %p Similar functionality to underscore.js - `nest` for `_.groupBy` etc

  %p Lots of other useful methods - `extend` gives max and min - worth a read


%section.subtitle
  %h2 Scales

%section
  %h2 Functional scales

  %p d3 can create our scales, so we don't need to.

  %pre
    :preserve
      var mapping = d3.scale.linear()
        .domain([d3.min(data), d3.max(data)])
        .range([0,VISUAL_SIZE_DESIRED]);

  %p Has built in colour scales that look lovely

%section
  %h2 Ranges and domains

  %p Domain is the range of values something has

  %p Range is a visual representation of that domain

  %p We map between them

%section
  %h2 First page menu

  %p Simple colour scale with steps.

  %pre
    :preserve
      var data = [0.05,0.1,0.1,0.1,0.1,0.1,0.45];

      var colors = d3.scale.linear().domain([0,data.length - 1]).range(["#69C7FF","#3593E6"])
      d3.select("#menu").selectAll("li").data(data)
        .append("div")
        .style("width",function(d) { return (d * 100).toFixed(0) + "%" })
        .style("height","16")
        .style("background",function(d,i) { return colors(i) });

%section.subtitle
  %h2 Layouts

%section
  %h2 Layouts

  %p Pure data: they don't do the laying out for you

  %p Most generic part of a layout is the algorithm to decide relative sizes/positions, that's what d3 gives you.

  %p Bound to the data, accessed as if you had a `dx` and `dy` in your data.

%section#layout-demo
  %h2 Histogram

  #histogram-1

  :javascript
    onPage("layout-demo",function() {

      var randomData = d3.range(1000).map(d3.random.irwinHall(10));

      var width = 800;
      var height = 500;

      var x = d3.scale.linear()
          .domain([0, 1])
          .range([0, width]);

      var data = d3.layout.histogram()
          .bins(x.ticks(20))
          (randomData);

      var y = d3.scale.linear()
          .domain([0, d3.max(data, function(d) { return d.y; })])
          .range([height, 0]);

      var svg = d3.select("#histogram-1").append("svg")
          .attr("width", width)
          .attr("height", height);

      svg.selectAll("rect")
          .data(data)
        .enter()
          .append("rect")
          .attr("transform", function(d) { return "translate(" + x(d.x) + "," + y(d.y) + ")"; })
          .attr("width", x(data[0].dx) - 1)
          .attr("height", function(d) { return height - y(d.y); });

    });

  .demo-code

  :javascript
    onPage("layout-demo",function() {
      revealCode("layout-demo",function(code,pre) {
        d3.select("#layout-demo .demo-code")[0][0].appendChild(pre); 
      }) 
    });

  %style
    :sass
      #histogram-1
        float: left
        width: 28%
      #layout-demo
        .demo-code
          float: left
          width: 70%
        pre
          padding: 0
          margin: 0

%section.subtitle
  %h2{style:"font-size:2em"} Tell me and I'll forget;<br/><br/> show me and I may remember;<br /><br/> involve me and I'll understand.

%section
  %h2 Hands on time

  %p We'll be building a real-time visualisation using reddit data

  %p
    Tweet your work in progress
    %a{href:"http://twitter.com/ga_london"} @GA_London
    , ask me how to setup a github page to host it.




%script{src:"prettify.js"}
%script{src:"main.js"}
